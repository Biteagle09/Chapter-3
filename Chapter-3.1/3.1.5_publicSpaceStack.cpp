#include "stdafx.h"

/********************王道2019年chapter-3.1 ，应用题第5题（P37）********************************
1、题目：
	设有两个栈s1、s2都采用顺序栈方式，并且共享一个存储区[0，…，maxsize-1]，为了尽量利用空间，减少溢出的可能，
	可采用栈顶相向、迎面增长的存储方式。试设计s1、s2有关入栈和出栈的操作算法。
2、算法思想：
	1°：两个栈共享向量空间，将两个栈的栈底设在向量两端，初始时，s1栈顶指针为-1，s2栈顶指针为maxsize；
	2°：两个栈顶指针相邻时为栈满。两个栈顶相向、迎面增长，栈顶指针指向栈顶元素。
	3°：此处规定，S1的栈底为存储区[0]位置，S2的栈底为存储区[MaxSize-1]位置;
	4°：stk是一个共享栈
**********************************************************************************************/



/**********************************************************************************
入栈操作。i为栈号，i=0表示左边的s1栈，i=1表示右边的s2栈，x是入栈元素
入栈成功返回1，否则返回-1
***********************************************************************************/
bool StkPush(Stk &stk, int i, int x) {
	if (!(i==0 || i==1)) {
		printf_s("您数输入的栈号不对！！！\n");
		return false;
	}
	if (stk.top[1] - stk.top[0] == 1) {
		printf_s("栈已满！！！\n");
		return false;
	}
	switch (i){
		case 0:
			stk.data[++stk.top[0]] = x;
			return true;
			break;
		case 1:
			stk.data[--stk.top[1]] = x;
			return true;
			break;
	}
}




/********************************************************************
退栈算法。i代表栈号，i=0时为s1栈，i=1时为s2栈
退栈成功返回退栈元素，否则返回-1
********************************************************************/
bool StkPop(Stk& stk, int i, int &e) {
	if (!(i == 0 || i == 1)) {
		printf_s("您数输入的栈号不对！！！\n");
		return false;
	}
	
	switch (i){
		case 0:
			if (stk.top[0] == -1) {
				printf_s("S1栈已空！！！\n");
				return false;
			}else {
				e = stk.data[stk.top[0]--];
				return true;
			}
		case 1:
			if (stk.top[1] == MaxSize) {
				printf_s("S2栈已空！！！\n");
				return false;
			}else {
				e = stk.data[stk.top[1]++];
				return true;
			}
	}

}